# 구현 계획


## 🧑‍💻 개발 우선순위 (MVP 중심)

**1, 2순위만 완성해도 앱의 핵심 기능은 문제 없이 동작한다**

### 🥇 1순위: '마이너' 플로우 완성 (핵심 CRUD)

* **목표:** 수동으로 리뷰를 작성, 저장, 조회, 삭제하는 앱의 기본 사이클을 완성
* **XML팀 (화면):**
    1.  **메인 화면 (`MainActivity`):**
        * 리뷰 목록을 보여줄 `RecyclerView` (지금은 비어있음)
        * 리뷰 작성 화면으로 넘어갈 `FloatingActionButton` ( '+' 버튼)
    2.  **리뷰 작성 화면 (`WriteActivity`):**
        * '마이너' 기준 수동 입력 폼 **(가장 중요)**
        * 카테고리(드롭다운), 제목(EditText), 사진첨부(ImageView), 별점(RatingBar), 리뷰(EditText), 태그(CheckBoxes), '저장' 버튼
    3.  **리뷰 상세/수정 화면 (`DetailActivity`):**
        * '작성 화면'과 거의 동일하지만, 기존 데이터를 채워서 보여줌.
        * '수정', '삭제' 버튼 추가.
* **Kotlin팀 (로직/DB):**
    1.  **Room DB 기본 설정:**
        * `Review` (리뷰) `@Entity` (데이터 클래스) 정의 **(가장 중요)**
        * `ReviewDatabase` (DB 객체) 생성
        * `ReviewDao` (DB 명령어) 인터페이스 정의
    2.  **DAO 기능 구현:**
        * `insert(review)` (저장)
        * `getAllReviews()` (메인 화면용, 최신순)
        * `getReviewById(id)` (상세 화면용)
        * `update(review)` (수정)
        * `delete(review)` (삭제)
    3.  **비즈니스 로직 (ViewModel):**
        * '저장' 버튼 로직: `WriteActivity`의 폼에서 데이터를 받아 `dao.insert()` 호출
        * 메인 화면 로직: `dao.getAllReviews()`를 호출해 `RecyclerView`에 데이터 연결
        * '수정', '삭제' 버튼 로직 구현

-----

### 🥈 2순위: 조회 및 통계 기능 (핵심 기능)

* **목표:** 1순위에서 저장한 데이터를 의미 있게 분석하고 검색
* **XML팀 (화면):**
    1.  **취향 보기 화면 (`TasteFragment`/`Activity`):**
        * "카테고리 순위", "태그 순위", "평균 별점"을 보여줄 `TextView`들
        * (선택) `Chart` 라이브러리를 사용해 그래프로 시각화
    2.  **내 리뷰 모아보기 화면 (`SearchFragment`/`Activity`):**
        * 필터 UI: 카테고리(드롭다운), 태그(CheckBoxes), 별점(Spinner/Slider)
        * '검색' 버튼
        * 결과를 보여줄 `RecyclerView` (1순위의 메인 화면과 재활용 가능)
* **Kotlin팀 (로직/DB):**
    1.  **DAO 기능 추가 (복잡한 쿼리):**
        * `getCategoryRank()` (GROUP BY, COUNT, ORDER BY)
        * `getTagRank()` (태그 데이터 분석 로직 필요)
        * `getAverageRating()` (AVG)
    2.  **DAO 기능 추가 (검색):**
        * `searchReviews(category, tags, rating)` (복잡한 WHERE 절 쿼리)
    3.  **비즈니스 로직 (ViewModel):**
        * 각 쿼리 결과를 계산/가공하여 XML팀이 표시하기 쉬운 `String`이나 `List`로 변환

-----

### 🥉 3순위: 설정 및 편의 기능 (개선)

* **목표:** '사용자 제작 카테고리' 기능을 추가합니다.
* **XML팀 (화면):**
    1.  **설정 화면 (`SettingsActivity`):**
        * '카테고리 관리' 메뉴
    2.  **카테고리 관리 화면:**
        * 사용자가 추가한 카테고리 목록 (`RecyclerView`)
        * 새 카테고리 추가(EditText + '추가' 버튼), 삭제(스와이프 등) UI
* **Kotlin팀 (로직/DB):**
    1.  **Room DB 수정:**
        * `Category` `@Entity` (테이블) 새로 추가
        * `CategoryDao` 추가 (insert, delete, getAll)
    2.  **핵심 로직 수정:**
        * **리뷰 작성 화면 (1순위)**: `CategoryDao.getAll()`을 호출해 카테고리 드롭다운을 동적으로 채우도록 수정
        * **카테고리 삭제 로직:** `ReviewDao`를 확인하여 "해당 카테고리를 쓰는 리뷰가 없으면" 삭제하도록 구현

-----

### 🏅 4순위: '메이저' 플로우 (API 연동)

* **목표:** 리뷰 작성 시 외부 API로 편의성을 더합니다.
* **XML팀 (화면):**
    1.  **리뷰 작성 화면 (1순위) 수정:**
        * '작품 검색' 버튼 추가
    2.  **검색 팝업/화면 (`SearchPopup`):**
        * 검색어 입력(EditText), '검색' 버튼
        * API 검색 결과를 보여줄 `RecyclerView`
* **Kotlin팀 (로직/API):**
    1.  **네트워크 설정 (가장 어려움):**
        * **Retrofit**, **Coroutines** 라이브러리 설정
        * 네이버 API 명세에 맞는 `ApiService` (인터페이스) 정의
        * API 응답(JSON)을 받을 `DTO` (데이터 클래스) 정의
    2.  **비즈니스 로직 (ViewModel):**
        * '작품 검색' 로직: Retrofit으로 네이버 API 호출 (코루틴 사용)
        * 결과(DTO)를 `RecyclerView`에 연결
        * 사용자가 특정 작품을 '선택'하면, 해당 정보(제목, 이미지)를 **'리뷰 작성 화면(1순위)'으로 들고 돌아가서** EditText와 ImageView에 **자동으로 채워주는** 로직 구현

> 필요하다면 네이버에서 데이터 몇 개를 가져와서 API처럼 보며주는 하드 코딩 방식으로 API 파트 구현해서 시연 가능. 보이기만 API처럼 보이면 발표에는 문제 없다고 하심!!

-----

## 🚀 1, 2 순위 작성만 마쳐 카테고리 추가 기능을 구현하지 못했을 경우

(하드코딩) 방식으로 해결

Kotlin팀: [1순위] '리뷰 작성' 화면을 개발할 때, 카테고리 드롭다운에 표시될 목록을 DB에서 불러오는 대신, 임시로 하드코딩합니다.

val categories = listOf("애니메이션", "소설", "드라마", "영화", "웹툰 (테스트용)")

이렇게 '웹툰 (테스트용)'이라는 **'가짜 마이너 카테고리'**를 그냥 목록에 포함시켜 버립니다.

XML팀: 그냥 이 categories 리스트를 받아서 드롭다운에 보여주면 됩니다.

-----

## 🤝 협업 워크플로우

가장 큰 문제는 XML팀과 Kotlin팀이 **"어떤 데이터를 주고받을지 약속(Contract)하지 않고"** 각자 개발하는 것입니다.

**'ViewModel'을 '계약서'로 사용하세요.** (MVVM 패턴)

### 스텝 1: '계약서' 정의 (함께 1시간)

기능 개발 시작 전, XML팀과 Kotlin팀이 **딱 1개의 파일**을 두고 함께 정의합니다. 바로 \*\*`ViewModel`\*\*입니다.

> **예: [1순위] '리뷰 작성' 기능을 개발할 때**

* Kotlin팀이 `WriteViewModel.kt`라는 빈 파일을 만듭니다.
* 두 팀이 모여 이 파일에 \*\*'주고받을 것'\*\*만 정의합니다.

<!-- end list -->

```kotlin
// WriteViewModel.kt (이게 '계약서'입니다)

class WriteViewModel : ViewModel() {
    
    // [Kotlin -> XML] 코틀린이 XML에게 "상태"를 알릴 때 사용 (LiveData)
    // "저장이 성공했는지 실패했는지 알려줄게"
    val saveStatus: LiveData<String> = ... 
    
    // [XML -> Kotlin] XML이 코틀린에게 "행동"을 명령할 때 사용 (Function)
    // "사용자가 '저장' 버튼을 눌렀어. 이 데이터로 저장해줘"
    fun onSaveButtonClicked(title: String, rating: Float, content: String, tags: List<String>) {
        // (여기는 지금 비워둠. Kotlin팀이 채울 것)
    }
}
```

* **XML팀의 약속:** "알겠어. 우리는 `onSaveButtonClicked` 함수만 호출할게. 그리고 `saveStatus`를 관찰(observe)해서 성공/실패 토스트를 띄울게."
* **Kotlin팀의 약속:** "알겠어. 우리는 `onSaveButtonClicked` 함수가 호출되면 Room DB에 저장하는 로직을 짤게. 그리고 끝나면 `saveStatus` 값을 '성공' 또는 '실패'로 바꿔줄게."

-----

### 스텝 2: '가짜(Mock)' 데이터로 병렬 개발 (각자 개발)

이제 두 팀은 헤어져서 **병렬로 개발**합니다.

* **XML팀:**
    * 화면(XML)을 예쁘게 만듭니다.
    * Kotlin팀의 *진짜* 로직이 완성될 때까지 기다릴 필요 없습니다.
    * \*\*'가짜 ViewModel'\*\*을 만들어 버튼 클릭을 테스트합니다.
    * *가짜 로직: `onSaveButtonClicked`가 호출되면 `saveStatus`를 무조건 '성공'으로 바꿈*
    * \-\> "오, '성공' 토스트가 잘 뜨네\! 우리 팀 개발 끝\!"
* **Kotlin팀:**
    * Room DB, DAO, Entity를 만듭니다.
    * XML 화면이 완성될 때까지 기다릴 필요 없습니다.
    * *진짜 로직: `onSaveButtonClicked`가 호출되면 DB에 `insert`하는 코드를 완성*
    * \-\> (단위 테스트를 통해) "오, DB에 저장이 잘 되네\! 우리 팀 개발 끝\!"

-----

### 스텝 3: 통합 및 테스트 (함께 1시간)

두 팀이 다시 모입니다.
XML팀이 사용하던 **'가짜 ViewModel'을 빼고, Kotlin팀이 만든 '진짜 ViewModel'로 교체**합니다.

'계약서'(ViewModel의 함수 이름, 변수 이름)를 정확히 지켰기 때문에 코드는 아무 문제 없이 합쳐집니다. 이제 진짜 '저장' 버튼을 눌러보고 DB에 데이터가 잘 들어가는지 확인하면 끝입니다.

이 방식을 1순위부터 4순위까지 모든 기능에 반복 적용하시면 됩니다.


-----

그럼요. 기획서와 논의한 개발 우선순위(MVP)를 바탕으로, XML팀과 Kotlin팀 간의 '명세서' 또는 '계약서' 역할을 할 **임시 뷰모델(ViewModel)** 초안을 짜보겠습니다.

이 뷰모델들은 **MVVM 아키텍처**를 기반으로 하며, 각 화면(Activity/Fragment)마다 하나씩 존재합니다.

* `LiveData` 또는 `StateFlow`: **Kotlin팀이 XML팀에게 전달할 데이터/상태**입니다. (화면에 보여줄 것들)
* `fun...()` (함수): **XML팀이 Kotlin팀에게 요청할 작업**입니다. (버튼 클릭 등)

-----

# 임시 뷰 모델 초안

## 🥇 1순위: '마이너' 플로우 (CRUD)

### 1\. `MainViewModel.kt` (메인 화면)

* **역할:** 저장된 모든 리뷰를 가져와서 메인 화면에 목록으로 뿌려줍니다.

<!-- end list -->

```kotlin
class MainViewModel : ViewModel() {

    // [Kotlin -> XML]
    // DB에 저장된 모든 리뷰 목록.
    // XML팀은 이 리스트를 관찰(observe)하여 RecyclerView에 표시합니다.
    val allReviews: LiveData<List<Review>> = // ... (Kotlin팀이 DAO에서 가져오는 로P)

    // [XML -> Kotlin]
    // XML팀: 사용자가 특정 리뷰 아이템을 클릭했습니다.
    // (Kotlin팀: 이 이벤트를 받아 상세 화면으로 이동하라는 Navigation Event를 발생시킴)
    fun onReviewClicked(review: Review) {
        // ... (화면 이동 로직 트리거)
    }

    // [XML -> Kotlin]
    // XML팀: 사용자가 '+' (리뷰 기록) 버튼을 클릭했습니다.
    // (Kotlin팀: 리뷰 작성 화면으로 이동하라는 Navigation Event를 발생시킴)
    fun onAddReviewClicked() {
        // ... (화면 이동 로직 트리거)
    }
}
```

-----

### 2\. `WriteViewModel.kt` (리뷰 작성/수정 화면)

* **역할:** 새 리뷰를 저장(Create)하거나 기존 리뷰를 수정(Update)/삭제(Delete)합니다.
* **핵심:** [3순위]가 개발되기 전까지 "Plan B" (카테고리 하드코딩)를 사용합니다.

<!-- end list -->

```kotlin
class WriteViewModel : ViewModel() {

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰(observe)해서 카테고리 드롭다운/Spinner를 채워주세요.
    // (Kotlin팀: [3순위] 개발 전까지, 여기에 임시로 '가짜 마이너 카테고리'를 포함해 하드코딩합니다.)
    val categories: LiveData<List<String>> = MutableLiveData(
        listOf("애니메이션", "소설", "드라마", "영화", "웹툰 (테스트용)") // <--- Plan B (하드코딩)
    )

    // [Kotlin -> XML]
    // (수정 모드일 경우) XML팀: 이 LiveData를 관찰해서 제목, 별점, 리뷰 등을 채워주세요.
    val existingReview: LiveData<Review> = // ...

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 "저장 완료!", "삭제 완료!" 같은 Toast 메시지를 띄워주세요.
    val processStatus: LiveData<String> = // ...

    // [XML -> Kotlin]
    // (수정 모드일 경우) XML팀: 상세 화면에서 '수정' 버튼을 누르면, 
    // 화면이 뜨자마자 이 함수를 호출해 기존 데이터를 불러옵니다.
    fun loadReviewData(reviewId: Long) {
        // ... (Kotlin팀: DAO에서 ID로 리뷰를 찾아 existingReview에 값을 넣어줌)
    }

    // [XML -> Kotlin]
    // XML팀: 사용자가 '저장' 또는 '수정 완료' 버튼을 눌렀습니다. 
    // 폼에 있는 모든 데이터를 이 함수에 넘겨주세요.
    fun onSaveButtonClicked(
        title: String,
        category: String,
        photoUri: String?, // 로컬 사진 경로 (선택적)
        rating: Float,
        reviewContent: String,
        tags: List<String> // 중복 선택된 태그 목록
    ) {
        // ... (Kotlin팀: 이 데이터를 Review 객체로 만들어 DAO의 insert 또는 update 호출)
    }

    // [XML -> Kotlin]
    // (수정 모드일 경우) XML팀: 사용자가 '삭제' 버튼을 눌렀습니다.
    fun onDeleteButtonClicked() {
        // ... (Kotlin팀: DAO의 delete 호출)
    }
}
```

-----

## 🥈 2순위: 조회 및 통계 기능

### 3\. `TasteViewModel.kt` (취향 보기 화면)

* **역할:** DB의 데이터를 분석/통계내어 XML팀에 전달합니다.

<!-- end list -->

```kotlin
class TasteViewModel : ViewModel() {

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 "1위: 소설, 2위: 애니..." 형식으로 TextView에 표시해주세요.
    val categoryRank: LiveData<String> = // ...

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 "1위: 로맨스, 2위: 액션..." 형식으로 TextView에 표시해주세요.
    val tagRank: LiveData<String> = // ...

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 "사용자님의 평균 별점은 4.75점입니다!" 형식으로 TextView에 표시해주세요.
    val averageRating: LiveData<String> = // ...

    // [XML -> Kotlin]
    // XML팀: 이 화면이 처음 열릴 때, 통계 계산을 시작하라고 이 함수를 호출해주세요.
    fun loadStats() {
        // ... (Kotlin팀: DAO에서 복잡한 쿼리(GROUP BY, AVG 등)를 실행해 위 LiveData들의 값을 갱신)
    }
}
```

-----

### 4\. `SearchViewModel.kt` (내 리뷰 모아보기 화면)

* **역할:** 사용자의 필터 조건에 맞는 리뷰 목록을 검색하여 제공합니다.

<!-- end list -->

```kotlin
class SearchViewModel : ViewModel() {

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 검색 결과 RecyclerView를 업데이트 해주세요.
    val searchResults: LiveData<List<Review>> = // ...

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 '카테고리' 필터 드롭다운을 채워주세요.
    // (WriteViewModel의 categories와 동일한 하드코딩 리스트)
    val filterCategories: LiveData<List<String>> = MutableLiveData(
         listOf("전체", "애니메이션", "소설", "드라마", "영화", "웹툰 (테스트용)")
    )
    
    // (태그, 별점 범위 필터는 UI가 고정되어 있으므로 LiveData가 필요 없을 수 있음)

    // [XML -> Kotlin]
    // XML팀: 사용자가 '검색' 버튼을 눌렀습니다.
    // 현재 선택된 필터 값들을 이 함수로 넘겨주세요.
    fun onSearchClicked(
        selectedCategory: String?, // "전체"이거나 선택 안됨 = null
        selectedTags: List<String>?, // 선택 안됨 = null
        ratingRange: Pair<Float, Float>? // 선택 안됨 = null
    ) {
        // ... (Kotlin팀: 이 조건들로 DAO의 복잡한 'search' 쿼리를 호출해 searchResults를 갱신)
    }
}
```

-----

## 🥉 3순위: 설정 (카테고리 관리)

### 5\. `SettingsViewModel.kt` (카테고리 관리 화면)

* **역할:** 사용자 정의 카테고리를 추가하고 삭제합니다.

<!-- end list -->

```kotlin
class SettingsViewModel : ViewModel() {

    // [Kotlin -> XML]
    // XML팀: DB에 저장된 사용자 정의 카테고리 목록입니다. RecyclerView로 보여주세요.
    val customCategories: LiveData<List<Category>> = // ... (DAO에서 Category 테이블 조회)

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 "추가 완료!", "삭제 완료!", "오류: 사용 중인 리뷰가 있습니다!"
    // 같은 Toast 메시지를 띄워주세요.
    val updateStatus: LiveData<String> = // ...

    // [XML -> Kotlin]
    // XML팀: 사용자가 새 카테고리 이름(EditText)을 입력하고 '추가' 버튼을 눌렀습니다.
    fun onAddCategoryClicked(categoryName: String) {
        // ... (Kotlin팀: DAO를 통해 Category 테이블에 새 이름 insert)
    }

    // [XML -> Kotlin]
    // XML팀: 사용자가 특정 카테고리(RecyclerView에서)를 '삭제'하려고 합니다.
    fun onDeleteCategoryClicked(category: Category) {
        // ... (Kotlin팀: 
        // 1. Review 테이블에 이 카테고리를 쓰는 리뷰가 있는지 '검사'
        // 2. 없으면 -> Category 테이블에서 삭제 후 updateStatus에 "삭제 완료!" 갱신
        // 3. 있으면 -> 삭제 안 함, updateStatus에 "오류..." 갱신
        // )
    }
}
```

**[중요\!]** [3순위]가 완성되면, [1순위] `WriteViewModel`의 `categories` LiveData는 더 이상 하드코딩이 아니라, `CategoryDao`에서 데이터를 가져오도록 **수정되어야 합니다.**

-----

## 🏅 4순위: '메이저' (외부 API 연동)

### 6\. `ApiSearchViewModel.kt` (작품 검색 팝업/화면)

* **역할:** [1순위] `WriteViewModel`을 **'도와주는'** 뷰모델. 네이버 API를 검색하고 결과를 되돌려줍니다.

<!-- end list -->

```kotlin
class ApiSearchViewModel : ViewModel() {

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 API 검색 결과 RecyclerView를 보여주세요.
    // (ApiMovieResult는 네이버 API 응답(JSON)에 맞게 Kotlin팀이 정의할 DTO/Data Class)
    val apiResults: LiveData<List<ApiMovieResult>> = // ...

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 로딩 스피너(ProgressBar)를 보여주거나 숨겨주세요.
    val isLoading: LiveData<Boolean> = // ...

    // [Kotlin -> XML]
    // XML팀: 이 LiveData를 관찰해서 "검색 결과가 없습니다", "네트워크 오류" 등을 띄워주세요.
    val errorMessage: LiveData<String> = // ...

    // [XML -> Kotlin]
    // XML팀: 사용자가 검색어(EditText)를 입력하고 '검색' 버튼을 눌렀습니다.
    fun onSearchQuery(query: String) {
        // ... (Kotlin팀: 
        // 1. isLoading을 true로 변경
        // 2. Retrofit + Coroutines로 네이버 API 비동기 호출
        // 3. 성공 -> apiResults 갱신, isLoading을 false로 변경
        // 4. 실패 -> errorMessage 갱신, isLoading을 false로 변경
        // )
    }

    // [XML -> Kotlin]
    // XML팀: 사용자가 검색 결과 목록(RecyclerView)에서 특정 작품을 '선택'했습니다.
    fun onResultSelected(selectedMovie: ApiMovieResult) {
        // ... (Kotlin팀: 이 선택된 영화 정보를 'WriteViewModel'에 전달해야 함)
        // (참고: 이 부분은 SharedViewModel이나 ActivityResultLauncher 등
        //  두 ViewModel 간의 데이터 전달 메커니즘이 필요하며, 가장 복잡한 부분입니다.)
    }
}
```

-----

### \#\# 👨‍🍳 'Kotlin팀' (로직팀)이 할 일

`...ViewModel.kt` 파일들을 *완성*하는 것**

Kotlin팀의 임무는 님이 보여주신 '계약서'의 **빈칸(`// ...`)을 채우는 것**입니다.

예를 들어, `MainViewModel.kt`에서 Kotlin팀은 `// ...` 부분을 이렇게 채워야 합니다. (이 코드는 예시입니다)

**`MainViewModel.kt` (Kotlin팀이 *채워 넣은* 코드)**

```kotlin
// (Repository는 DAO를 관리하는 중간 관리자라고 가정)
class MainViewModel(private val repository: ReviewRepository) : ViewModel() {

    // [Kotlin -> XML]
    // XML팀은 이 리스트를 관찰(observe)하여 RecyclerView에 표시합니다.
    // ▼▼▼ Kotlin팀이 채워야 할 '빈칸' ▼▼▼
    val allReviews: LiveData<List<Review>> = repository.getAllReviews().asLiveData()

    // [XML -> Kotlin]
    // ...
    // (화면 이동 로직도 여기에 구현)
    // ▲▲▲ Kotlin팀이 채워야 할 '빈칸' ▲▲▲
}
```

* **Kotlin팀의 책임:** `repository.getAllReviews()` 같은 **실제 DB 접근 로직**을 구현하고, `allReviews`라는 `LiveData` 변수에 \*\*'진짜 데이터'\*\*를 채워 넣습니다.

-----

### \#\# 👩‍💼 'XML팀' (UI팀)이 할 일

**= `...Activity.kt` / `...Fragment.kt` 파일을 짜는 것**

XML팀의 임무는 Kotlin팀이 완성한 `ViewModel`을 **'가져다 쓰는(호출하는)' 코틀린 코드**를 짜는 것입니다.

예를 들어, `MainActivity.kt`에서 XML팀은 `MainViewModel`을 이렇게 *사용*합니다.

**`MainActivity.kt` (XML팀이 *짜야 하는* '연결' 코드)**

```kotlin
// (이 파일은 님이 붙여넣은 코드가 아닙니다!)
class MainActivity : AppCompatActivity() {

    // 1. Kotlin팀이 만든 'ViewModel'을 가져옵니다.
    private val viewModel: MainViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main) // XML팀이 만든 XML 연결

        val myRecyclerView: RecyclerView = findViewById(R.id.my_recycler_view)
        val myAdapter = ReviewAdapter() // (RecyclerView 어댑터도 XML팀이 만듦)
        myRecyclerView.adapter = myAdapter

        // 2. Kotlin팀이 채워둔 'allReviews'를 '관찰'합니다.
        viewModel.allReviews.observe(this) { reviewList ->
            // Kotlin팀이 데이터를 주면, XML팀은 화면(어댑터)에 뿌려줍니다.
            myAdapter.submitList(reviewList)
        }

        // 3. XML팀이 만든 '버튼'에 '연결'합니다.
        val addButton: Button = findViewById(R.id.add_button)
        addButton.setOnClickListener {
            // Kotlin팀이 만든 'onAddReviewClicked' 함수를 '호출'합니다.
            viewModel.onAddReviewClicked()
        }
    }
}
```

* **XML팀의 책임:** `observe`, `setOnClickListener` 등을 사용해 \*\*XML(화면)\*\*과 \*\*ViewModel(기능)\*\*을 \*\*'연결'\*\*합니다.

-----



### **'아키텍처의 역할(Layer)'**로 나눠진 팀

* **XML팀 (View Layer / UI팀)**
    * **역할:** 사용자에게 '보여지는 모든 것'을 책임집니다.
    * **작업물 1 (메인):** `activity_write.xml` (화면 배치, 디자인, 색상)
    * **작업물 2 (필수):** `WriteActivity.kt` (XML과 뷰모델을 **'연결'**하는 코드)
    * `WriteActivity.kt`에서 이 팀이 작성할 코드는 다음과 같습니다. (이전 답변 내용)
        1.  `setOnClickListener` 설정 (사용자 입력을 뷰모델에 '전달')
        2.  `viewModel.observe` 설정 (뷰모델의 데이터를 UI에 '표시')
    * **이 팀은 'DB 저장 로직'이나 'API 호출 로직'은 전혀 몰라도 됩니다.**

* **Kotlin팀 (ViewModel / Logic팀)**
    * **역할:** 눈에 '보이지 않는 모든 것'(데이터, 로직)을 책임집니다.
    * **작업물 1 (메인):** `WriteViewModel.kt` (뷰모델 '계약서'의 **'내용'**을 채우기)
    * **작업물 2 (필수):** `ReviewDatabase.kt`, `ReviewDao.kt` (DB 관련 로직)
    * **작업물 3 (선택):** `ApiService.kt` (API 관련 로직)
    * **이 팀은 '버튼'이 동그란지 네모난지, '글자' 색이 파란지 빨간지 전혀 몰라도 됩니다.**

---

